#!/usr/bin/env ruby
require_relative '../dlog'
require 'digest'
require 'optparse'

class Options
  attr_accessor :mode, :sleep

  def initialize
    @mode = :once
    @sleep = 5.seconds
  end

  def self.from_args(args)
    opts = Options.new
    op = OptionParser.new do |o|
      o.on "-w", "--watch", "Watch file for changes and fixup once it does" do |v|
        opts.mode = v ? :loop : :once
      end

      o.on("-s", "--sleep [SECONDS]", OptionParser::DecimalInteger, "When looping, wait for SECONDS between checking file") do |v|
        opts.sleep = v.clamp(1, 3_600)
      end
    end.parse!(ARGV)

    opts
  end

  def loop?; @mode == :loop end
  def once?; @mode == :once end

  def log(msg)
    $stderr.puts "[#{DateTime.now}] #{msg}"
  end

  def daily_log
    cfg = find_and_load_user_config
    path_to_daily_log(cfg)
  end

  def daily_log_hash
    file_path = Pathname.new(daily_log)
    return unless file_path.size?

    sha256 = Digest::SHA256.new
    File.open(file_path.to_s, 'rb') do |file|
      while chunk = file.read(1024)  # Read the file in chunks
        sha256.update(chunk)
      end
    end
    sha256.hexdigest  # Return the hex digest of the hash
  end
end

########################################
# Main
########################################
opts = Options.from_args(ARGV)
prev_hash = ""
fix_on_next_falling_edge = false

opts.log "Starting..."
if opts.loop?
  opts.log "mode=#{opts.mode}  sleep=#{opts.sleep.to_s}s"
end
loop do
  current_hash = opts.daily_log_hash
  if current_hash != prev_hash
    if prev_hash.present?
      opts.log "File has changed! '#{prev_hash}' != '#{current_hash}'"
    end
    fix_on_next_falling_edge = true
  elsif current_hash == prev_hash && fix_on_next_falling_edge
    fix_on_next_falling_edge = false
    opts.log "Fixing up #{opts.daily_log}"
    main_fixup

    # Update the 'current_hash' so we don't trigger a change from our change
    current_hash = opts.daily_log_hash
  elsif current_hash == prev_hash
    opts.log "No change #{current_hash}"
  end

  # Fast 1st Loop
  if prev_hash.blank?
    prev_hash = current_hash
    next
  end

  # Do the correct thing
  prev_hash = current_hash
  if opts.once? && fix_on_next_falling_edge
    opts.log "XXXXXXXXXX"
  else
    break unless opts.loop?
    sleep opts.sleep.to_i
  end
end
opts.log "Exiting"
