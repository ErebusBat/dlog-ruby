#!/usr/bin/env ruby
require_relative '../dlog'
require 'optparse'

class Options
  attr_accessor :mode

  # :loop mode properties
  attr_accessor :sleep, :write_delay, :log_freq, :cache_config

  attr_reader :start_tick

  def initialize
    # Time to wait between checking file for changes
    @sleep = 5.seconds

    # Time to wait AFTER changes have been detected before
    # initiating the write
    @write_delay = 1.second

    # How often should no change messages be output when looping
    self.log_freq = 1.minute
    @last_log_tick = 0

    # Should config be cached?  If true then it will still be reloaded at the midnight boundry
    @cache_config = true

    # loop or once
    self.mode = :once

    @start_tick = current_tick
  end

  def current_tick
    Process.clock_gettime(Process::CLOCK_MONOTONIC)
  end

  def running_ticks
    current_tick - @start_tick
  end

  def log_freq=(v)
    @log_freq = v.to_i
    if @log_freq < 0
      @log_freq = Integer::MAX
    end
  end

  def mode=(v)
    v = v.to_sym
    unless [:once, :loop].include?(v)
      raise "Invalid mode '#{v}'"
    end

    if v == :once
      @write_delay = 0
    end
    @mode = v
  end

  def self.from_args(args)
    opts = Options.new
    op = OptionParser.new do |o|
      o.on "-w", "--watch", "Watch file for changes and fixup once it does" do |v|
        opts.mode = v ? :loop : :once
      end

      o.on("-s", "--sleep [SECONDS]", OptionParser::DecimalInteger, "When looping, wait for SECONDS between checking file") do |v|
        opts.sleep = v.clamp(1, 3_600)
      end

      o.on("-d", "--delay [SECONDS]", OptionParser::DecimalInteger, "Time to wait after a change has been detected until a fixup occurs") do |v|
        opts.write_delay = v.clamp(0, 3_600)
      end

      o.on("--log-no-change [SECONDS]", OptionParser::DecimalInteger, "Time between 'no change' log messages") do |v|
        opts.log_freq = v.to_i
      end

      o.on("--[no-]cache-config", "Read cache every time or not") do |v|
        opts.cache_config = v
      end
    end.parse!(ARGV)

    opts
  end

  def loop?; @mode == :loop end
  def once?; @mode == :once end

  # Log, but respect log_freq
  def log_throttle(msg)
    should_log = false
    should_log = true if once?
    should_log = true if current_tick - @last_log_tick >= @log_freq

    return unless should_log

    log(msg)
  end

  # Write to log NOW
  def log(msg)
    $stderr.puts "[#{DateTime.now}] #{msg}"
    @last_log_tick = current_tick
  end

  def config
    cfg_loaded_today = @config_loaded_on == Date.today
    load_cfg = false
    load_cfg = true if @config.nil?
    load_cfg = true if !cfg_loaded_today
    load_cfg = true if !cache_config

    if load_cfg
      # If we are not caching then we don't want to show the load logs on every call
      # HOWEVER we do want to show then on the first run and every
      show_log = cache_config && loop?
      @last_config_loaded_tick ||= -1
      if current_tick - @last_config_loaded_tick >= 86_400
        show_log = true
      elsif !cfg_loaded_today
        show_log = true
      end

      # Output log first so we know what happened if there is an error
      log "t=#{running_ticks.to_i} Loading configuration" if show_log
      @config = find_and_load_user_config
      @config_loaded_on = Date.today
      @last_config_loaded_tick = current_tick
      log "Found vault=#{vault_root(@config)}" if show_log
      log "   Log File=#{path_to_daily_log(@config)}" if show_log
    end

    @config
  end

  def vault_root(cfg=config)
    vault = Vault.new(cfg)
    vault.config.vault_root
  end

  def daily_log_path
    path_to_daily_log(config)
  end

  def daily_log_human
    vroot = vault_root.to_s + "/"
    path = daily_log_path.to_s
    path.sub(vroot, '')
  end

  def daily_log_hash
    file_path = Pathname.new(daily_log_path)
    return unless file_path.size?

    sha256 = Digest::SHA256.new
    File.open(file_path.to_s, 'rb') do |file|
      while chunk = file.read(1024)  # Read the file in chunks
        sha256.update(chunk)
      end
    end
    sha256.hexdigest  # Return the hex digest of the hash
  end
end

########################################
# Main
########################################
opts = Options.from_args(ARGV)
prev_hash = ""
fix_on_next_falling_edge = false

opts.log "Starting..."
if opts.loop?
  # opts.log "mode=#{opts.mode}  sleep=#{opts.sleep.to_s}s  write_delay=#{opts.write_delay}s"
  opts.log [
    "mode=#{opts.mode}",
    "sleep=#{opts.sleep.to_s}s",
    "write_delay=#{opts.write_delay}s",
    "log_freq=#{opts.log_freq}s",
    "cfg_cached=#{opts.cache_config}",
  ].join("  ")
end

loop do
  current_hash = opts.daily_log_hash
  ticks_s = "t=#{opts.running_ticks.to_i}"

  if current_hash != prev_hash
    if prev_hash.present?
      opts.log "#{ticks_s} #{opts.daily_log_human} File has changed!"
    end
    fix_on_next_falling_edge = true
  elsif current_hash == prev_hash && fix_on_next_falling_edge
    fix_on_next_falling_edge = false

    prev_hash = current_hash
    # Check if this is the first pass
    # We want to run immediately on start, THEN start delaying
    if opts.running_ticks > 10
      opts.log "Changes stabilized, waiting for #{opts.write_delay}s to fixup"
      sleep opts.write_delay
    end

    # Now make sure the file hasn't changed in our delay time
    current_hash = opts.daily_log_hash
    if current_hash != prev_hash
      opts.log "#{opts.daily_log_human} File changed during delay period, not fixing up"
      prev_hash = current_hash
      fix_on_next_falling_edge = true
      next
    end

    opts.log "#{ticks_s} #{opts.daily_log_human} Examining File"
    result = main_fixup
    if result
      opts.log "#{ticks_s} #{opts.daily_log_human} Log Fixed Up!"
    else
      opts.log "#{ticks_s} #{opts.daily_log_human} No log changes, detected."
    end

    # Update the 'current_hash' so we don't trigger a change from our change
    current_hash = opts.daily_log_hash
  elsif current_hash == prev_hash
    opts.log_throttle "#{ticks_s} #{opts.daily_log_human} No change"
  end

  # Fast 1st Loop
  if prev_hash.blank?
    prev_hash = current_hash
    next
  end

  # Do the correct thing
  prev_hash = current_hash
  break unless opts.loop?

  sleep opts.sleep.to_i
end
opts.log "Exiting"
