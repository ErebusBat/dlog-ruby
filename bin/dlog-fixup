#!/usr/bin/env ruby
require_relative '../dlog'
require 'digest'
require 'optparse'

class Options
  attr_accessor :mode

  # :loop mode properties
  attr_accessor :sleep, :write_delay, :log_freq

  def initialize
    # Time to wait between checking file for changes
    @sleep = 5.seconds

    # Time to wait AFTER changes have been detected before
    # initiating the write
    @write_delay = 1.second

    # How often should no change messages be output when looping
    self.log_freq = 1.minute
    @last_log_tick = 0

    # loop or once
    self.mode = :once
  end

  def current_tick
    Process.clock_gettime(Process::CLOCK_MONOTONIC)
  end

  def log_freq=(v)
    @log_freq = v.to_i
    if @log_freq < 0
      @log_freq = Integer::MAX
    end
  end

  def mode=(v)
    v = v.to_sym
    unless [:once, :loop].include?(v)
      raise "Invalid mode '#{v}'"
    end

    if v == :once
      @write_delay = 0
    end
    @mode = v
  end

  def self.from_args(args)
    opts = Options.new
    op = OptionParser.new do |o|
      o.on "-w", "--watch", "Watch file for changes and fixup once it does" do |v|
        opts.mode = v ? :loop : :once
      end

      o.on("-s", "--sleep [SECONDS]", OptionParser::DecimalInteger, "When looping, wait for SECONDS between checking file") do |v|
        opts.sleep = v.clamp(1, 3_600)
      end

      o.on("-d", "--delay [SECONDS]", OptionParser::DecimalInteger, "Time to wait after a change has been detected until a fixup occurs") do |v|
        opts.write_delay = v.clamp(0, 3_600)
      end

      o.on("--log-no-change [SECONDS]", OptionParser::DecimalInteger, "Time between 'no change' log messages") do |v|
        opts.log_freq = v.to_i
      end
    end.parse!(ARGV)

    opts
  end

  def loop?; @mode == :loop end
  def once?; @mode == :once end

  # Log, but respect log_freq
  def log_throttle(msg)
    should_log = false
    should_log = true if once?
    should_log = true if current_tick - @last_log_tick >= @log_freq

    return unless should_log

    log(msg)
  end

  # Write to log NOW
  def log(msg)
    $stderr.puts "[#{DateTime.now}] #{msg}"
    @last_log_tick = current_tick
  end

  def daily_log
    cfg = find_and_load_user_config
    path_to_daily_log(cfg)
  end

  def daily_log_hash
    file_path = Pathname.new(daily_log)
    return unless file_path.size?

    sha256 = Digest::SHA256.new
    File.open(file_path.to_s, 'rb') do |file|
      while chunk = file.read(1024)  # Read the file in chunks
        sha256.update(chunk)
      end
    end
    sha256.hexdigest  # Return the hex digest of the hash
  end
end

########################################
# Main
########################################
opts = Options.from_args(ARGV)
prev_hash = ""
fix_on_next_falling_edge = false

opts.log "Starting..."
if opts.loop?
  # opts.log "mode=#{opts.mode}  sleep=#{opts.sleep.to_s}s  write_delay=#{opts.write_delay}s"
  opts.log [
    "mode=#{opts.mode}",
    "sleep=#{opts.sleep.to_s}s",
    "write_delay=#{opts.write_delay}s",
    "log_freq=#{opts.log_freq}s",
  ].join("  ")
end

loop do
  current_hash = opts.daily_log_hash
  if current_hash != prev_hash
    if prev_hash.present?
      opts.log "#{opts.daily_log} File has changed!"
    end
    fix_on_next_falling_edge = true
  elsif current_hash == prev_hash && fix_on_next_falling_edge
    fix_on_next_falling_edge = false

    opts.log "Changes stabilized, waiting for #{opts.write_delay}s to fixup"
    prev_hash = current_hash
    sleep opts.write_delay

    # Now make sure the file hasn't changed in our delay time
    current_hash = opts.daily_log_hash
    if current_hash != prev_hash
      opts.log "#{opts.daily_log} File changed during delay period, not fixing up"
      prev_hash = current_hash
      fix_on_next_falling_edge = true
      next
    end

    opts.log "#{opts.daily_log} Fixing up"
    main_fixup

    # Update the 'current_hash' so we don't trigger a change from our change
    current_hash = opts.daily_log_hash
  elsif current_hash == prev_hash
    opts.log_throttle "#{opts.daily_log} No change"
  end

  # Fast 1st Loop
  if prev_hash.blank?
    prev_hash = current_hash
    next
  end

  # Do the correct thing
  prev_hash = current_hash
  break unless opts.loop?

  sleep opts.sleep.to_i
end
opts.log "Exiting"
